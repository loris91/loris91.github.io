
<!DOCTYPE html>
<html>
 <head> 
  <title>Playground</title> 
  <style>
    body{
      margin: 0;
      overflow: hidden;
    }

    #stats {  /* Align stats top-left */
      position: absolute;
      left: 0px;
      top: 0px;
    }
  </style> 
  </head>
  <body>
  <!-- JavaScript libraries -->
  <script src="assets/libs/three.min.js"></script> 
  <script src="assets/libs/jquery.min.js"></script>
  <script src="assets/libs/Stats.min.js"></script>
  <script src="assets/libs/dat.gui.min.js"></script>
  <script src="assets/libs/TrackballControls.js"></script>
  <script src="assets/libs/PointerLockControls.js"></script>
  <script src="assets/libs/tween.min.js"></script>
  <script src="assets/libs/OBJLoader.js"></script> 
  <script src="assets/libs/MTLLoader.js"></script>
  <script src="assets/libs/OBJMTLLoader.js"></script>
  <!-- Javascript code that runs our Three.js examples --> 
  <script>
    // once everything is loaded, we run our Three.js stuff.
    $(function () {

      var stats = initStats();

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene();

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10000);

      // create trackball controls
      var trackballControls = new THREE.TrackballControls(camera);

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer();
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0));
      webGLRenderer.setSize(window.innerWidth, window.innerHeight);

      // position and point the camera to the center of the scene
      camera.position.set(180,0,500);
      camera.up = new THREE.Vector3(0,0,1);
      camera.lookAt(scene.position);

      // add spotlights
      var spotLight1 = new THREE.DirectionalLight(0xffffff);
      spotLight1.position.set(-3000, 4000, 5000);
      spotLight1.intensity = 1;
      scene.add(spotLight1);

      var spotLight2 = new THREE.DirectionalLight(0xffffff);
      spotLight2.position.set(3000, -4000, -5000);
      spotLight2.intensity = 1;
      scene.add(spotLight2);

      // add the output of the renderer to the html element
      $('body').append(webGLRenderer.domElement);

      var objectsss = [];

      var axisHelper = new THREE.AxisHelper(1000);
      scene.add(axisHelper); 

      var planeG = new THREE.PlaneGeometry(1000,1000,100,100);
      var planeM = new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true});
      var plane = new THREE.Mesh(planeG,planeM);
      //scene.add(plane);
































function createMesh(geom, imageFile, bump, mapping, mapX, mapY) {
  var texture = THREE.ImageUtils.loadTexture("assets/textures/" + imageFile)
  geom.computeVertexNormals();
  var mat = new THREE.MeshPhongMaterial();
  mat.map = texture;

  if (bump) {
    var bump = THREE.ImageUtils.loadTexture("assets/textures/" + bump)
    mat.bumpMap = bump;
    mat.bumpScale = 0.2;
  }
  
  var mesh = new THREE.Mesh(geom, mat);

  if (mapping) {
    mesh.material.map.repeat.set(mapX,mapY);
    mesh.material.map.wrapS = THREE.RepeatWrapping;
    mesh.material.map.wrapT = THREE.RepeatWrapping; 
  }

  return mesh;
}










































function make_Balcony() {

  var balcone = new THREE.Object3D();

  var shape1 = new THREE.Shape();
    shape1.moveTo(0,0);
    shape1.lineTo(80,0);
    shape1.lineTo(80,225);
    shape1.lineTo(0,225);
    shape1.lineTo(0,0);
  var hole1 = new THREE.Path();
    hole1.moveTo(5,5);
    hole1.lineTo(75,5);
    hole1.lineTo(75,220);
    hole1.lineTo(5,220);
    hole1.lineTo(5,5);
  shape1.holes.push(hole1);
  var option1 = {
    amount: 10,
    bevelThickness: 10,
    curveSegments: 30,
    steps: 100,
    bevelEnabled: false
  };


  var shape2 = new THREE.Shape();
    shape2.moveTo(5,5);
    shape2.lineTo(75,5);
    shape2.lineTo(75,220);
    shape2.lineTo(5,220);
    shape2.lineTo(5,5);
  var hole2_1 = new THREE.Path();
    hole2_1.moveTo(10,10);
    hole2_1.lineTo(70,10);
    hole2_1.lineTo(70,110);
    hole2_1.lineTo(10,110);
    hole2_1.lineTo(10,10);
  var hole2_2 = new THREE.Path();
    hole2_2.moveTo(10,115);
    hole2_2.lineTo(70,115);
    hole2_2.lineTo(70,215);
    hole2_2.lineTo(10,215);
    hole2_2.lineTo(10,115);
  shape2.holes.push(hole2_1);
  shape2.holes.push(hole2_2);
  var option2 = {
    amount: 8,
    bevelThickness: 10,
    curveSegments: 30,
    steps: 100,
    bevelEnabled: false
  };

  var material_alluminio = new THREE.MeshPhongMaterial(
    { specular: 0xffffff, color: 0xCD7F32, shininess: 100, metal: true });
  var material_vetro = new THREE.MeshLambertMaterial({ color: 0x99CBFF, opacity: 0.3, transparent: true });

  var geometry1 = new THREE.ExtrudeGeometry(shape1,option1);
  var corniceEsterna = new THREE.Mesh(geometry1,material_alluminio);

  var geometry2 = new THREE.ExtrudeGeometry(shape2,option2);
  var anta = new THREE.Mesh(geometry2,material_alluminio);


  var glassUp = new THREE.Mesh( new THREE.BoxGeometry(70,100,4), material_vetro);
  var glassDown = new THREE.Mesh( new THREE.BoxGeometry(70,100,4), material_vetro);

  var hook = new THREE.Object3D();


  balcone.add(corniceEsterna);
  corniceEsterna.add(hook);
  balcone.hook = hook;
  balcone.rotation.x = Math.PI/2;
  balcone.rotation.y = Math.PI/2;
  balcone.isClose = true;

  hook.add(anta);
  hook.position.set(77,110,5);
  anta.position.set(-77,-110,-4);
  anta.add(glassUp);
  glassUp.position.set(40,60,3);
  anta.add(glassDown);
  glassDown.position.set(40,165,3);


  glassUp.animate = function() {
    balcone.animate();
  }

  glassDown.animate = function() {
    balcone.animate();
  }

  anta.animate = function() {
    balcone.animate();
  }

  balcone.animate = function() {
    if(this.isClose) {
      this.open_balcony.start();
      this.isClose = false;
    } else {
      this.close_balcony.start();
      this.isClose = true;
    }
  } 

  balcone.open_balcony = new TWEEN.Tween(balcone.hook.rotation)
   .to({ y: 0.5*Math.PI}, 1000)

  balcone.close_balcony = new TWEEN.Tween(balcone.hook.rotation)
   .to({ y: 0*Math.PI}, 1000)




  return balcone;
  
  
}

      var balcone1 = make_Balcony(); 
      scene.add(balcone1);

      objectsss.push ( balcone1.children[0].children[0].children[0] );
      objectsss.push ( balcone1.children[0].children[0].children[0].children[0] );
      objectsss.push ( balcone1.children[0].children[0].children[0].children[1] );




       render();


      function render() {
        stats.update();
        trackballControls.update();
        TWEEN.update();

        // render using requestAnimationFrame
        requestAnimationFrame(render);
        webGLRenderer.render(scene, camera);
      }

      var projector = new THREE.Projector();
      document.addEventListener('mousedown', onDocumentMouseDown, false);

      function onDocumentMouseDown(event) {
        event.preventDefault();

        // map viewport coordinates in ([-1,1], [-1,1], 0.5)
        var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
        projector.unprojectVector(vector, camera);

        var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

        var intersects = raycaster.intersectObjects(objectsss);

        if (intersects.length > 0) {
          intersects[0].object.animate();
        }
      }





          
      function initStats() {
        var stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms
        $('body').append(stats.domElement);
        return stats;
      }
    });
  </script>  
 </body>
</html>
